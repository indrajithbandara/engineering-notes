1. Введение

Сразу отмечу, что приведенные в статье примеры скриптов представляют собой предельно упрощённые решения задач сетевого администрирования. Это сделано преднамеренно – для удобства восприятия читателями. После того как вы освоите синтаксис и семантику команд, усовершенствовать эти скрипты можно будет самостоятельно.

В начало
2. Выполнение команды настройки на удалённом компьютере

Достаточно часто в локальной сети возникает необходимость выполнения команды настройки среды на какой-либо рабочей станции. Рассмотрим такую ситуацию: на одном из компьютеров периодически требуется синхронизация даты и времени из-за неполадок аппаратного таймера.

Эту проблему поможет решить следующий скрипт. Предположим, что с датой и временем некорректно обращается компьютер по имени comp052.

01: #!/usr/bin/expect
02: spawn ssh <имя_пользователя>@comp052
03: expect "password:"
04: send "<пароль_пользователя>\r"
05: expect -re "\\$ $"
06: send "su\r"
07: expect "(Password:|Пароль:)"
08: send "<пароль_root>\r"
09: expect -re "# $"
10: exec date > /tmp/datesync.tmp
11: exec cat /tmp/datesync.tmp
12: set newtime [exec cat /tmp/datesync.tmp]
13: send "date -s \"$newtime\"\r"
14: expect -re "# $"
15: send "exit\r"
16: expect -re "\\$ $"
17: send "logout\r"
18: expect "closed."
19: exit 0

Со всеми командами вы уже знакомы по примерам в предыдущих статьях цикла. Отмечу лишь, что двухступенчатая процедура регистрации в качестве обычного пользователя и последующего перехода в ранг суперпользователя обусловлена требованиями безопасности при работе через ssh. Практически во всех системах соблюдается рекомендация: запретить непосредственный вход суперпользователя root по протоколу SSH.

Команда вывода содержимого файла /tmp/datesync.tmp (строка 11) на локальную консоль позволяет зафиксировать в системном журнале время выполнения данного скрипта.

Подразумевается, что вместо условных "шаблонов" <имя_пользователя>, <пароль_пользователя> <пароль_root> подставляются реально существующие на обслуживаемом компьютере (в данном примере – comp52) имя, пароль и пароль суперпользователя соответственно.

Описанный выше скрипт можно поместить в системную таблицу crontab и запланировать его выполнение с требуемой периодичностью.

В начало
3. Автоматизация выполнения команды rsync на удалённом компьютере

Ещё одна задача сетевого администрирования – резервное копирование определённых данных и параметров настройки на сетевых компьютерах. В небольшой сети для администратора не составит труда выполнить несколько команд rsync вручную. А если сеть состоит из нескольких десятков или даже сотен машин? Снова зовём на помощь Expect.

В следующем примере команда rsync использует протокол SSH – безопасность превыше всего.

Скрипт принимает два аргумента: имя хоста, с которого производится резервное копирование, и пароль суперпользователя root на этом хосте.

01: #!/usr/bin/expect -f
02: if {[llength $argv] != 2} {
03:   puts "Вызов: auto_rsync.exp <ИМЯ_ХОСТА> <ПАРОЛЬ_ROOT>"
04:   exit 1
05: }
06: set hostname [lindex $argv 0]
07: set password [lindex $argv 1]
08: set timeout -1
09: spawn date
10: expect -re "# $"
11: spawn rsync -av -e ssh $hostname:/etc /archive/sys
12: expect "password:" {send "$password\r"}
13: expect -re "# $"
14: spawn date
15: expect -re "# $"
16: spawn rsync -av -e ssh $hostname:/usr/etc /archive/sys
17: expect "password:" {send "$password\r"}
18: expect -re "# $"
19: spawn date
20: expect -re "# $"
21: spawn rsync -av -e ssh $hostname:/usr/work /archive/works
22: expect "password:" {send "$password\r"}
23: expect -re "# $"
24: spawn date
25: expect -re "# $"
26: exit 0

Здесь необходимы некоторые пояснения. В строке идентификации (01) использован флаг -f, непосредственно предваряющий файл, из которого считываются команды. Собственно говоря, он как раз и предназначен для #!-нотации с тем, чтобы в командной строке могли быть заданы другие аргументы. В нашем случае такими аргументами являются имя хоста и пароль суперпользователя.

В строках 02–05 выполняется проверка наличия названных выше аргументов, поскольку без них скрипт работать не будет.

С инициализацией переменных (строки 06 и 07) вы уже знакомы, а вот в строке 08 для переменной timeout задаётся значение -1, которое означает, что прерывания выполнения по тайм-ауту не будет, т.е. время ожидания не ограничено.

Фиксация даты и времени (строка 09 и далее по тексту) будет выполняться перед началом каждой операции и после её окончания.

В строках 11, 16 и 21 выполняется команда rsync, в которой флаг -a инициализирует режим архивирования, флаг -v позволяет выводить подробную информацию о ходе выполнения команды, а флаг -e предоставляет возможность задать командную оболочку: в нашем случае это ssh.

Скрипт можно выполнять из командной строки или запланировать его выполнение с помощью системных средств (cron или at), или поместить в скрипт-"обёртку" командной оболочки, в котором используется цикл для перебора всех необходимых хостов.

В начало
4. Организация совместной работы пользователей

Как уже было отмечено ранее, в состав установочного пакета Expect включены уже готовые скрипты, предназначенные для выполнения задач администрирования. Один из этих скриптов – kibitz – предоставляет весьма любопытные возможности.

Дон Либис с изрядной долей юмора дал такое имя (в переводе с английского kibitz – вмешиваться в чужие дела; давать непрошеные советы) скрипту, который позволяет двум или даже нескольким пользователям одновременно работать с одной программой: это может быть командная оболочка, текстовый редактор и т.д. Ограничение только одно – это должны быть программы с символьным (текстовым) интерфейсом. Запуск программ с графическим интерфейсом возможен, но при этом не гарантируется нормальный вид и поведение таких программ. Впрочем, это ограничение устраняется с помощью ещё одного скрипта xkibitz, который позволяет нормально работать с X-программами, а кроме того, обеспечивает динамическое подключение и отключение пользователей во время работы.

Для того чтобы начать работу, пользователь (назовём его user1) запускает скрипт, передавая ему в качестве аргумента имя другого пользователя, с которым он намеревается взаимодействовать (пусть это будет user2):

kibitz user2

При этом активизируется новый экземпляр командной оболочки (или какая-либо другая программа, которую можно задать в командной строке), а пользователю user2 предлагается также выполнить скрипт kibitz. В приглашение включается уникальный идентификатор для того, чтобы избежать конфликтов с другими сеансами kibitz. В действительности этот идентификатор представляет не что иное, как просто идентификатор исходного процесса kibitz. Второй пользователь получает приблизительно такое сообщение:

Can we talk? Run: kibitz -4077
EOF

После того как user2 выполнит указанную в сообщении команду (kibitz -4077), все нажатия клавиш обоих пользователей становятся вводом для общей командной оболочки. Соответственно, оба пользователя получают вывод оболочки.

Для того чтобы завершить сеанс kibitz, достаточно просто выйти из "совместной" командной оболочки, нажав клавиши Ctrl-D или введя команду exit. После выхода одного из пользователей происходит автоматический выход из оболочки и второго пользователя, в результате чего сеанс kibitz завершается.

В сетевой среде, когда вызываемый пользователь работает на другом хосте, команда инициализации сеанса kibitz выглядит следующим образом:

kibitz user2@host02

Канал связи создаётся с помощью утилиты rlogin. Если удалённый компьютер запрашивает пароль, то kibitz перехватывает этот запрос и предлагает вызывающему пользователю ввести требуемый пароль. Все прочие подробности установления соединения скрыты от пользователей.

После установления соединения и инициализации сеанса kibitz вторым пользователем всё выглядит так, как если бы оба пользователя работали на одном компьютере. Завершение сеанса производится точно так же, как описано выше.

Если необходимо организовать сеанс с участием более двух пользователей, то можно воспользоваться таким вариантом команды:

kibitz user2@host02 kibitz user3@host03 kibitz user4@host04

Такой "массовый сеанс" вполне пригоден, например, для обучения и для консультаций, когда опытный пользователь наглядно показывает начинающим, как выполняются различные операции, следит за их действиями, отвечает на вопросы и т.п. Разумеется, для организации подобного сеанса необходимо, чтобы на всех хостах-участниках был установлен пакет программ Expect.

Запуск консольного текстового редактора в kibitz-сеансе позволяет провести "интерактивное совещание" с ведением протокола или организовать совместное редактирование документов.

В начало
4.1. Использование kibitz как команды, встраиваемой в Expect-скрипты

Несмотря на то что kibitz является интерактивным скриптом (а с другой стороны – именно благодаря этому), его можно применять как команду, включаемую в сценарии автоматизации, написанные на Expect.

Предположим, что имеется Expect-скрипт, запускаемый сервисом cron или переведённый в фоновый режим выполнения. Обобщённая схема такого скрипта может выглядеть следующим образом:

01: spawn <некоторый_процесс>; set proc_id $spawn_id
    ...
    <Expect-команды>
    ...
    # предположим, что в ходе выполнения возможно возникновение проблемы
    # или вопроса, требующего вмешательства пользователя
02: spawn kibitz -noproc <имя_пользователя>
03: send "Возникла ситуация, требующая вмешательства пользователя\n"
04: interact -u $proc_id
05: send "Проблема решена, продолжаю выполнение\n"

Здесь при инициализации сеанса kibitz (строка 02) используется флаг "-noproc", который позволяет обойтись без создания нового процесса, а вместо этого напрямую подключить создаваемый сеанс к текущему процессу. Таким образом, обеспечивается доступ заданного пользователя к выполняющемуся процессу, в котором возникла проблема.

Возможность выполнения пользователем необходимых действий предоставляется командой interact (строка 04). Эта Expect-команда устанавливает связь между двумя "сущностями". Первая "сущность" – это пользователь, которому передаётся управление процессом. Вторая "сущность" определяется с помощью флага "-u" с аргументом, которым обязательно должен быть идентификатор текущего процесса, требующего взаимодействия с пользователем.

После того как пользователь выполнит все необходимые действия и завершит интерактивный kibitz-сеанс, выдаётся соответствующее сообщение (строка 05), управление возвращается Expect-скрипту и его работа продолжится.

В начало
5. Заключение

Expect можно считать диалектом языка программирования Tcl, специализированным для выполнения задач администрирования. Основное предназначение Expect – объединение двух и более интерактивных программ и обеспечение их функционирования без участия пользователя.

С помощью всего лишь нескольких базовых команд можно создавать скрипты различной степени сложности, обеспечивающие взаимодействие многочисленных программ и автоматизацию их выполнения.

В этом цикле статей были описаны основные функциональные принципы и рассмотрены вопросы практического применения Expect, а также приведены примеры скриптов для решения задач системного администрирования.


================================================================================


Использование expect в bash скриптах
Март 13, 2015 admin

Expect - это оболочка предоставляющая возможность програмировать диалог с интерактивными програмами. Под интерактивными програмами подразумеваются приложения, которые требуют ввода дополнительной информации в ходе работы.

Тяжело объяснить без примера. О примерах использвания expect дальше и пойдет речь. Планируется сборная статья, которая будет пополнятся разнообразными примерами использования expect.

Есть два варианта, по аналогии с perl/python:

    Создать скрипт-файл и запустить его следующим образом:

        expect -f script.exp

    Выполнить expect с командами в виде параметров:

        expect -c ' что-то сделать\r'

"\r" в конце строки означает отправку команды (нажатие клавиши Enter).

Основная структура скрипта:

#!/usr/bin/expect
spawn #выполняемое приложение или команда
expect #определяет в ответ на какой вопрос нужно отправить следующие ланные
send #что отправить в ответ на предыдущий вопрос

Если Вы хотите передать в скрипт какие-то параметры и использовать их в работе воспользуйтесь директивой set:

set var1 [lindex $argv 0] #первый параметр передаваемый скрипту
set var2 [lindex $argv 1] #второй параметр передаваемый скрипту

Используйте interact в конце, если по завершению выполнения всех send'ов сесия должна оставаться активной. Удобно для автоматизации при работе с ssh.
Пример 1: SSH

Стандартному линуксовому ссш клиенту можно стравить имя пользователя и ipадрес сервера как аргуметы, но пароль ему нельзя передать. Следующие скрипт принимает в качестве аргументов имя пользователя и пароль, дальше подключается с ними к серверу 192.168.1.10 и выполняет там cat /etc/issue

#!/usr/bin/expect
log_file expect_log
set login [lindex $argv 0]
set pw [lindex $argv 1]

spawn ssh $login@192.168.1.10
expect "$login@192.168.1.10\'s password:"
send "$pw\r"
expect "$login@"
send "cat /etc/issue\r"

Выполнить его можно так:

    expect -f script.exp user password

Второй вариант - запустить все прямо в bash:

    expect -c 'spawn ssh user@192.168.1.10; expect "Password:" {send -- "password\r"}; expect "user@" {send "cat /etc/issue\r"};'

Согласитесь, если у Вас есть список серверов, с паролями и логинами, то можно сгенерировать батч и автоматизировать выполнение определенной команды на всех серверах.

Весь вывод можно записать в лог использовав следующую конструкцию в начале файла:

log_file expect_log

Немаловажным является время выполнения. Я не помню значение по умолчанию, но хорошей практивой является установка таймаута на выполнение:

set timeout 86000

Пример 2: FTP

Допустим нужно загрузить содержимое 10-ти ftp серверов в один каталог на сервере. Представьте использование 10-ти комбинаций логинов, паролей и адрдресов в lftp. Представили? Страшно?

Я вышел из ситуации следующим образом:

1. Создал файл со следующим содержанием:

#!/bin/bash
expect -c 'set timeout 86000; spawn lftp '"$1"'; expect "Password:" {send -- "'"$2"'\r"}; expect ">" {send "mirror -c --parallel=10\r"}; expect "/>" {send "exit\r"};'

2. Дальше катнул, эхнул, седнул и авкушнул оригинальный файл и получил новый файл в котором первая колонка - пользователь@ip_сервера, вторая - пароль.

    user1@server1 password1
    user1@server2 password2
    user1@server3 password3
    ...
    user1@serverN passwordN

3. В bash запустил следующу команду:

    i=1 && end=$(cat file.txt |wc -l) && while [ $i -le $end ];do cmd=$(sed -n "$i"p file.txt |awk '{print $1}'); pwd=$(sed -n "$i"p file.txt |awk '{print $2}'); bash get_src $cmd $pwd; let "i = $i + 1";done

С помощью rsync загружаем выбраные папки с сервера

На сервере с Plesk файлы сайтов лежат в папках /var/www/vhosts/имя_сайта/httpdocs.

У нас есть список сайтов:

    web-сайт1.com
    web-сайт2.com
    web-сайт3.com
    web-сайт4.com
    web-сайт5.com
    web-сайт6.com
    web-сайт7.com
    web-сайт8.com
    web-сайт9.com

Нужно стянуть папки этих сайтов на новый сервер.

В подобных случаях я инициализирую в bash список с названием list:

    list="web-сайт1.com
    web-сайт2.com
    web-сайт3.com
    web-сайт4.com
    web-сайт5.com
    web-сайт6.com
    web-сайт7.com
    web-сайт8.com
    web-сайт9.com"

Подсказка: Набираете сначала list=", потом делаете вставку из буфера обмена, потом закрываете список двойными кавычками "

Дальше цыклом for перебираю эллементы списка:

    for f in $list;do
    mkdir -p /var/www/vhosts/$f;
    expect -c 'spawn rsync -Hogva root@ip_адрес:/var/www/vhosts/$f/httpdocs /var/www/vhosts/$f/; expect "password:" {send -- "пароль\r"};interact';
    done


    ===========================================================================

    Автоматизируем работу в интерактивных консольных программах используя expect

В жизни сетевого инженера (да и не только), наступает такой момент, когда некоторые рутинные операции надоедает выполнять, и хочется их оптимизировать. В один прекрасный день я понял, что каждый раз когда мне нужно авторизоваться на коммутаторе, то набирать логин\пароль, а затем ещё пароль на enable мне надоело. Поэтому данное действие было решено как-то оптимизировать. Взяв бутылочку пенного я сел за "работу"..

В компании где я работаю, по определённым обстоятельствам авторизация на коммутаторах\роутерах\DSLAM и прочем оборудовании происходит не по ssh, а по telnet. Средствами самого telnet возможности передать логин\пароль нет, поэтому поиск с попутным распитием алкоголя продолжился, и остановился на утилите expect.

Expect - это утилита, которая парсит потоковый вывод консольных программ, и в ответ на них отправляет какой либо заранее предусмотренный "ответ". Например, при подключении к ftp серверу, ожидаем получить запрос на ввод пароля, и при его получении - отправляем его.

Для моей задачи expect подошёл идеально. Да и как оказалось, у одного из коллег уже был небольшой expect скрипт для этих целей, который, правда, не совсем подходил мне, но для ознакомления с expect пришёлся весьма кстати.

Чтобы более или менее понять, рассмотрим для начала небольшой expect скрипт, который авторизует пользователя на ftp сервере:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15



#!/usr/bin/expect -f

spawn ftp example.com

expect {
    "Name:" {
        send "testuser\n"
        expect "Password:"
        send "testpass\n"
        expect "ftp>"
        send "passive\n"
    }
}

interact

В первой строке мы записываем sha-bang, которым указывает командной оболочке, что этот скрипт следует интерпретировать как expect-script (запустить expect и передать ему скрипт). Затем используя spawn вызываем программу ftp и передаём ей в качестве аргумента адрес хоста, к которому хотим подключиться. И вот самое интересное - блок expect {}. В нём мы сообщаем интерпретатору, что ожидаем "Name: ", и в ответ с помощью send отправляем логин и символ перевода каретки \n (Enter). Затем ожидаем получить запрос на ввод пароля, отправляем пароль и переводим ftp-клиент в пассивный режим (send "passive\n"). В самом конце у нас interact который указывает, что необходимо по завершении сценария передать управление пользователю.

Если сильно раздражает вывод программ во время выполнения скрипта, то можно отключить это добавив log_user 0.

Если что-то во время выполнения скрипта идёт не так, то можно посмотреть более подробно, какие данные получает expect, нашёл ли совпадения, и что посылает в ответ. Для этого надо добавить exp_internal 1 в код скрипта:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16



#!/usr/bin/expect -f

spawn ftp example.com
exp_internal 1

expect {
    "*Name*" {
        send "testuser\n"
        expect "Password:"
        send "testpass\n"
        expect "ftp>"
        send "passive\n"
    }
}

interact

Выполним скрипт:

spawn ftp example.com

expect: does "" (spawn_id exp6) match glob pattern "*Name*"? no
Connected to example.com.

expect: does "Connected to example.com.\r\n" (spawn_id exp6) match glob pattern "*Name*"? no
220 (vsFTPd 2.3.2)
Name (example.com:testuser):
expect: does "Connected to example.com.\r\n220 (vsFTPd 2.3.2)\r\nName (example.com:testuser): " (spawn_id exp6) match glob pattern "*Name*"? yes
expect: set expect_out(0,string) "Connected to example.com.\r\n220 (vsFTPd 2.3.2)\r\nName (example.com:testuser): "
expect: set expect_out(spawn_id) "exp6"
expect: set expect_out(buffer) "Connected to example.com.\r\n220 (vsFTPd 2.3.2)\r\nName (example.com:testuser): "
send: sending "testuser\n" to { exp6 }

expect: does "" (spawn_id exp6) match glob pattern "Password:"? no
testuser

expect: does "testuser\r\n" (spawn_id exp6) match glob pattern "Password:"? no
331 Please specify the password.
Password:
expect: does "testuser\r\n331 Please specify the password.\r\nPassword:" (spawn_id exp6) match glob pattern "Password:"? yes
expect: set expect_out(0,string) "Password:"
expect: set expect_out(spawn_id) "exp6"
expect: set expect_out(buffer) "testuser\r\n331 Please specify the password.\r\nPassword:"
send: sending "testpass\n" to { exp6 }

expect: does "" (spawn_id exp6) match glob pattern "ftp>"? no


expect: does "\r\n" (spawn_id exp6) match glob pattern "ftp>"? no
530 Login incorrect.
Login failed.

expect: does "\r\n530 Login incorrect.\r\nLogin failed.\r\n" (spawn_id exp6) match glob pattern "ftp>"? no
ftp>
expect: does "\r\n530 Login incorrect.\r\nLogin failed.\r\nftp> " (spawn_id exp6) match glob pattern "ftp>"? yes
expect: set expect_out(0,string) "ftp>"
expect: set expect_out(spawn_id) "exp6"
expect: set expect_out(buffer) "\r\n530 Login incorrect.\r\nLogin failed.\r\nftp>"
send: sending "passive\n" to { exp6 }
tty_raw_noecho: was raw = 0  echo = 1
spawn id exp6 sent  >
passive
Passive mode on.
ftp>

Видно, что после отправки пароля, ftp сервер снова его спрашивает. Значит, ошиблись где-то в логине или пароле.

Теперь пример сложнее. Скрипт выше делает то, что нам нужно в данном случае, но в нём есть некоторые недостатки: для каждого хоста необходимо создавать новый скрипт; если сайт недоступен, то скрипт будет вести себя весьма странно.
Исправим эти недостатки немного модифицировав его (для удобства добавленные\изменённые участки кода прокомментированы):

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28



#!/usr/bin/expect -f

if {[llength $argv] != 1} { # проверяем количество переданных аргументов скрипту
    send_user  "This script requires an argument: ftp host to connect"
    exit 1 # если аргументов нет - завершаем выполнение скрипта с ошибкой
}

set HOST [lindex $argv 0] # в переменную HOST записываем первый аргумент - адрес хоста
spawn ftp $HOST # запускаем ftp и передаём аргумент $HOST
set timeout 3 # устанавливаем время ожидания expect в 3 секунды
set USERNAME "testuser" # имя пользователя и пароль так же вынесли в переменные для удобства
set PASSWORD "testpass"

expect {
    "220 (vsFTPd ?????)" { # сейчас ожидаем строки с приветствием ftp сервера
        expect "Name:"
        send "$USERNAME\n"
        expect "Password:"
        send "$PASSWORD\n"
        expect "ftp>"
        send "passive\n"
    } timeout { # выжидаем timeout
        send_user "Unnable connect to $HOST"
        exit 1
        }
}

interact

Внимательный читатель наверняка заметил, что в приветствии ftp сервера вместо версии - вопросительные знаки. Дело в том, что expect может проверять соответствия используя регулярные выражения, или (по-умолчанию) на основе wildcards. В данном случае неизвестные цифры версии ftp сервера мы заменили на "?".
Далее вместо строки для поиска совпадений мы указываем интерпретатору, что если совпадений не нашли, ждём определённый промежуток времени указанный в set timeout, выводим сообщение об ошибке и завершаем выполнение скрипта.
В принципе, на этом стоит закончить с данным примером, но можно добавить ещё один интересный штрих: убрать лишний вывод. В данном примере, если expect не нашёл совпадений, наше сообщение об ошибке будет трудно заметить на фоне остального вывода. Отключить его можно добавив log_user 0. В любом нужном месте его можно включить заменив 0 на 1. Всё что отправлено с помощью send_user будет по-прежнему выводиться.

Всё бы хорошо, но всё ещё чего-то не хватает скрипту, что-то не так... И правда: проверка таким образом доступности ftp сервера не самая лучшая идея.
Хороший выход из данной ситуации - это нужную нам часть вынести в bash скрипт, проверку доступности выполнять обычным пингом, а количество аргументов средствами самого bash:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30



#!/bin/bash

# Проверяем количество аргументов
if [ ! "$#" -eq 1 ]
then
        echo "1 arguments required, $# provided"
        exit 1
fi

# Проверяем доступность хоста
if ( ! ping -c1 -i1 -n -s10 -W1 $1  &>/dev/null )
then
        echo "Host $1 not available"
        exit 1
fi


USERNAME="testuser"
PASSWORD="testpass"

/usr/bin/expect<<EOF
    spawn ftp $1
    expect "Name*"
    send "$USERNAME\n"
    expect "Password:"
    send "$PASSWORD\n"
    expect "ftp>"
    send "passive\n"
    expect eof
EOF

Комментировать часть скрипта написанного на bash я не буду - для этого есть ресурсы лучше. Какой либо особой магии здесь нет. Просто проверяем количество аргументов переданных скрипту, доступность сервера для подключения и если всё в порядке - запускаем expect передавая ему команды. expect eof здесь нужен чтобы скрипт не завершался сразу после выполнения.

Раз уж мы заговорили про использование expect в bash, то коснёмся и сбора данных. Для примера давайте представим, что есть сферический ftp сервер в вакууме, с которого зачем-то нужно раз в сутки собирать список имеющихся директорий. Ситуация надуманная, но для примера подойдёт:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34



#!/bin/bash

if [ ! "$#" -eq 1 ]
then
        echo "1 arguments required, $# provided"
        exit 1
fi

if ( ! ping -c1 -i1 -n -s10 -W1 $1  &>/dev/null )
then
        echo "Host $1 not available"
        exit 1
fi


USERNAME="testuser"
PASSWORD="testpass"

DIRLIST=$(expect -c "
    set timeout 3
    spawn ftp $1
    expect \"Name*\"
    send \"$USERNAME\n\"
    expect \"?assword:\"
    send \"$PASSWORD\n\"
    expect \"ftp>\"
    send \"passive\n\"
    expect \"ftp>\"
    send \"ls\n\"
    expect \"ftp>\"
    send \"bye\n\"
")

echo "$DIRLIST" | sed -e '1,14d' | head -n -2 > $1_dirlist.txt

Пример принципиально не сильно отличается от предыдущего. В переменной DIRLIST запускаем expect и построчно выполняем скрипт. Следует обратить внимание, что так как мы запустили expect внутри bash, то надо дополнительно экранировать посылаемые и ожидаемые данные. Далее работаем с полученными результатами как с простым текстом.

Для моих нужд в результате получился такой скрипт:

 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63



#!/bin/bash

username="username"
password="password"
enpassword="enablepassword"
enpassword2="enablepassword2"

# IP-адрес берём из буфера обмена
ip=$(xsel -p)
re="^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$"

# Убираем всё ненужное от ip-адреса
ip=`echo $ip | sed -e 's/^[ \t]+|[ \t]+$//g'`
ip=`echo $ip | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}'`

# проверяем правильный ли ip-адрес это
if [[ ! $ip =~ $re ]] || [[ "${#ip}" -ge 16 ]] || [[ "${#ip}" -eq 0 ]]; then
    notify-send "Telnet" "Error while extracting IP address"
                                               -u normal
                                               -i gtk-dialog-warning
                                               -t 8000
    exit 0;
fi

# проверяем доступность хоста
if ( ! fping -c1 -t500 $ip &>/dev/null ); then
    notify-send "Telnet" "Host $ip not available. Check connection."
                                               -u normal
                                               -i gtk-dialog-warning
                                               -t 8000
    exit 1
fi

# В этой переменной храним собственно сам скрипт
commands="
spawn telnet $ip
expect {
    # Cisco
    \"User Access Verification\" {
        send \"$username\n\"
        expect \"Password: \"
        send \"$password\n\"
        send \"enable\n\"
        send \"$enpassword\"
    }

    # Some other switch\router
    \"Station's information:\" {
        send \"$username\n\"
        expect \"PassWord:\"
        send \"$password\n\"
        send \"enable\n\"
        send \"$enpassword2\n\"
    }

    # and so on...
}
interact
"

gnome-terminal --geometry 120x30+30+20
              --title "Telnet to $ip"
              --execute /usr/bin/expect -c "$commands"

Доступность хоста проверяется с помощью fping, т.к. он позволяет задать меньший timeout ответа от хоста. После всех необходимых действий с входными данными, скрипт запускает gnome-terminal, в нём интерпретатор expect которому передаётся скрипт в виде переменной commands. В компании где я работаю, много разного оборудования управление которым осуществляется через telnet, поэтому в скрипте несколько блоков expect - почти на каждый тип устройства. Здесь я оставил несколько.


===============================================================================

Картинок на эту тему особо нет, а в статье и вообще не будет, поэтому привлечём ваше внимание обложкой замечательной книги


Немного истории и оффтопика

В начале 2013го я вернулся в дополнительное образование детей, получил 24 часа еженедельной нагрузки для четырёх групп «юных программистов» и «юных системных администраторов», и приступил к набору учеников на двух площадках: моём собственном кабинете и кабинете информатики находящейся неподалёку гимназии. Силами групп «юных системных администраторов» мы привели свой кабинет в порядок, развернув AltLinux 6 и парочку альтернативных дистрибутивов. А в гимназии очень опытный «инженер компьютерного класса» давно вёл эксперименты с source-based, закончившиеся приходом Calculate Linux на все машины учителей и учебных классов. Респект ему)

Задача

Через пару месяцев занятий я увидел проблему. Дети отказывались уходить с занятий, любым способом стараясь задержаться подольше. Т.к. педагогические технологии — это не моё, а кружок у нас всё-таки технический, я убивал сторонние процессы и выключал машины по ssh. Это повысило интерес учеников к изучению возможностей командной строки. Однако скоро они нашли баг: выключение «руками» занимает слишком много времени, и даже в небольшом кабинете они успеют перезапустить половину машин до того, как я завершу карательный процесс, и это затянет дело. Чтобы продемонстрировать кто здесь главный лучшие возможности программирования для командной строки, я задумался об автоматизации.

Варианты решения

Нулевой мыслью было использование italc, и мы даже уделили несколько недель его настройке и экспериментам. Но он оказался слишком глючен и примитивен, поэтому был благополучно забыт.

Первой же мыслью было настроить доступ через ssh по отпечатку. Это сократило бы задачу до одного цикла, но для применения «на коленке» этот способ оказался не совсем пригоден (хотя почему нет? ЕМНИП, отпечаток для пользователя также можно создать без рута). Но при доступной авторизации по паролю (кстати, большой ущерб безопасности для учебных классов, где логин-пароли одинаковы) меня заинтересовал вариант с автоматической авторизацией по паролю. Уделив час поиску, я нашёл несколько примеров для expect.

Решение через expect

Перед началом

Но, во первых, он должен быть установлен. В моём классе мы без труда сделали это, а вот в классе гимназии ВНЕЗАПНО оказалось, что и expect, и nmap, и некоторые другие интересные системные утилиты не только установлены, но и доступны ученику. Это очень помогло нам, когда в очередной раз «упал» прикрученный по NFS сетевой диск, и мы нашли способ распространения заданий через быстро найденный бухгалтерский компьютер с расшаренными дисками.

Во вторых, кроме самого expect, нам понадобится использовать 2 типа цикла: с предусловием и с параметром. Первый необходим для «зацикливания» процесса, чтобы можно было повесить выполнение скрипта фоном на всё занятие. Второй же необходим для перебора необходимых адресов, на которые мы будем заходить по ssh при помощи собственно expect.

Также необходимо помнить, что стандартно скрипт выпадает при возникновении первой же ошибки, например неответе компьютера клиента, и наверное стоит поискать способ обработки таких исключений.

Скрипт

Сообщаем, что для выполнения нам необходимо использовать нестандартный интерпретатор

#!/usr/bin/expect -f



Задаём паузу для ожидания ответа с клиента, имя пользователя и пароль (это скорее по инерции из имеющихся в сети примеров):

set timeout 2
set USER "u1"
set PASS "1"



Начало сценария:

while 1 {   // применение цикла с предусловием
foreach HOST {58 60 61} {     // применение цикла с параметром для списка окончаний адресов. Да, их можно генерировать и автоматически, но пост не об этом
spawn ssh $USER@192.168.0.$HOST // подключаемся
  expect {
  "(yes/no)?*" {
  send "yes\r" // не забывайте про \r в конце строки, перед кавычками. Иначе волшебства не получится
 }
  }
   expect "word:"
  send "$PASS\r"
  expect "$*"
  send "killall -r teew*\r"
  expect "$*"
  send "killall firefox\r"
  expect "$*"
  send "killall chrome\r"
  expect "$*"
  send "exit\r"
  expect eof
 }



Это был простой скрипт автоубивания ненужных процессов для гимназии. В своём же кабинете я модифицировал скрипт и для автовыключения машин:

guest@0-315-gymn2 ~ $ cat scripty
#!/usr/bin/expect -f
set timeout 2
set USER "user"
set HOST "2"
set PASS "2357"
# Начало сценария
 while 1 {
 foreach HOST {2 3 5 7} {
  spawn ssh $USER@192.168.0.$HOST
  expect {
  "(yes/no)?*" {
  send "yes\r"
  }
  }
  expect "word:"
  send "$PASS\r"
  expect "$*"
  send "su\r"
  expect "word:*"
  send "supassword\r"
  expect "#*"
  send "/sbin/shutdown 0 -hP\r"
  expect "#*"
  send "exit\r"
  expect "$*"
  send "exit\r"
  expect eof
 }
 }



Заключение

Надеюсь, упоминание замечательного интерпретатора expect и пара живых примеров по работе с ним будут полезны сообществу и породят немало статей о более тонких его применениях.

P.S.:

Скрипт автопоиска активных компьютеров и создания списка адресов для обработки чуть позже написал один мой ученик (не делать же всё интересное самому). Чуть позже, когда заслужит инвайт, он сможет сам написать об этом в применении к более интересной задаче.

===============================================================================
Есть основания надеяться
Автоматизация работы интерактивных приложений с помощью Expect...

Александр Красоткин
Автоматизация работы интерактивных приложений с помощью Expect

В повседневной работе администратора сети или обычного пользователя значительную часть времени занимает выполнение типовых, однообразных задач. Получение и передача файлов по ftp, сбор статистики с различных устройств, диагностика и администрирование рабочего состояния компьютерных систем. Все эти задачи объединены сходными признаками: они являются интерактивными; число возможных вариантов выполнения задачи ограничено.

Примером такой задачи является копирование файла по ftp. Приведем типичный сценарий получения файла с ftp-сервера (ответы пользователя выделены жирным шрифтом):

$ftp ftp.nsc.rut
220 FTP server ready
Name (ftp.uu.net: user): anonymous
331 Guest login ok, send your complete
 e-mail address as password
Password: user@domen.ru
230 Guest login ok, access restriction apply
Remote system type is UNIX.
Using binary mode to transfer files.
ftp>binary
200 Type set to I.
ftp>cd pub/rf
550 system: No such file or directory
ftp> cd inet/rfc
250 CWD command successful.
ftp> get rfc959.Z
local: rfc959.Z remote: rfc959.Z
200 PORT command successful.
150 Opening BINARY mode data connection
 for rfc959.Z (48587 bytes).
226 Transfer complete.
48587 bytes received in 14.5 secs
 (3.3 Kbytes/sec)
ftp>quit
221 Goodbye.

После завершения этой операции мы получили документ RFC 959, описывающий FILE TRANSFER PROTOCOL (FTP). Операция заняла около минуты. Из полученного документа можно узнать, что при успешном выполнении команды смены каталога ftp-сервер возвращает строку, содержащую код 250. При получении файла код 200 означает, что файл найден и с этого момента начинается его получение. Код 226 означает, что передача файла успешно завершена.

Для автоматизации операции воспользуемся системой Expect1. Рассмотрим сценарий ftp-rfc.exp. У него только одна задача — получить с ftp-сервера файл rfc959.txt.

#!/usr/bin/expect -f
set file "rfc959.txt"
spawn ftp ftp.nsc.ru
expect "Name*:"
send "anonymous
"
expect "Password:"
send "user@domen.ru
"
expect "ftp>"
send "binary
"
expect "ftp>"
send "cd pub/rfc
"
expect "250*ftp>"
send "get $file
"
expect "200*226*ftp>"
send "quit"
close
#-- end of script --

Как видно, в сценарии четыре ключевых момента:

    spawn - вызов программы ftp-клиента с заданными параметрами (ftp.nsc.ru);
    expect - ожидание вывода запущенной программой строки, совпадающей с текстовым шаблоном (expect "200
    226
    ftp>");
    send - передача данных или команд в вызванную программу (send "anonymous ");
    close - завершение сценария.

Идеология сценария довольно понятна, не правда ли? Система Expect создает для приложения имитацию работы с пользователем — псевдотерминал. По сценарию, определенному пользователем, принимаются данные и передаются команды.

Рассмотрим подробнее, что же представляет собой система Expect.
История и назначение Expect

В сентябре 1987 г. Дон Либес (Don Libes) из Национального института стандартов и технологий (National Institute of Standart and Technology) начал работу над системой Expect, предназначенной для управления интерактивными программами. В настоящее время Expect является расширением языка Tcl, поддерживается языками программирования Си и Perl, добавляя к ним расширенные возможности отладки и удобные команды для описания символьно-ориентированных диалогов.

Необходимо отметить одно важное достоинство системы Expect — единый командный интерфейс. Используя термины и команды Expect, можно построить сценарий управления любой интерактивной программой вне зависимости от ее специфики.
Получение и установка Expect

Дистрибутив последней версии для Unix-систем находится на официальном Web-сервере системы Expect. Для установки системы требуются программные пакеты Tcl (необходим) и Tk (необязателен). Далее:

$tar xvzf expect.tar.gz
$cd expect-X.XX
$./configure && make && /bin/su
#make install

Если установка прошла успешно, двигайтесь дальше. Иначе:

$less INSTALL

Первая программа

Являясь расширением Tcl, Expect наследует и обогащает его лексику. Используя предоставленные возможности, сделаем из приведенного выше сценария нечто более удобное для работы.

#!/usr/bin/expect -f
if $argc!=1 {
send_user "Usage: ftp-rfc.exp
 index_rfc
"
exit
}
set file "rfc$argv.txt"
set timeout 60
spawn ftp ftp.nsc.ru
expect "Name*:"
send "anonymous
"
expect "Password:"
send "user@domen.ru
"
expect "ftp>"
send "binary
"
expect "ftp>"
send "cd pub/rfc
"
expect "550*ftp>" exit
 "250*ftp>"
send "get $file
"
expect "550*ftp>" exit
 "200*226*ftp>"
exec less $file
#-- end of script --

Модифицированный скрипт ftp-rfc.exp, приобретя в качестве аргумента индекс документа RFC, обращается к FTP-серверу ftp.nsc.ru, получает соответствующий документ и выводит его на экран пользователя. Осуществляется проверка кода возврата каждой выполняемой операции. После завершенной неудачно (не найден файл, каталог и т. п.) выполнение скрипта прерывается.

Рассмотрим более подробно основные методы и переменные системы Expect.
Краткий обзор системы Expect

Команда Close — закрыть соединение с текущим процессом

debug [[-now] 0|1]
-now

означает осуществить запуск отладчика Tcl (дебаггера) немедленно — с текущей операции

0 | 1

Остановить (0) или запустить (1) отладчик со следующей операции.

Метод, вызванный без параметров, возвращает 1, если отладчик не запущен, и 0 в противном случае.

Команда Disconnect отсоединяет созданный (forked) процесс от терминала и переводит в фоновый режим. Ввод/вывод процесса перенаправляется в /dev/null. Пример использования:

set delay 3600
send_user "password? "
expect_user -re "(.*)
"
for {} 1 {} {
if [fork]!=0 {sleep $delay;continue}
disconnect
spawn priv_prog
expect Password:
send "$expect_out(1,string)
"
. . .
exit
}

Приведенный сценарий считывает пароль и переходит в фоновый режим. Затем каждый час запускает программу, требующую идентификации по паролю. Таким образом, введя пароль только один раз, можно запускать данную программу бесконечно.

Преимущество использования метода disconnect перед переводом программы в фоновый режим параметром & командной оболочки ($program &) состоит в том, что Expect способен сохранять параметры терминала до отсоединения и затем применить их к создаваемому псевдотерминалу. При выполнении команды программной оболочки & Expect не считывает параметры терминала, так как, когда Expect получит контроль, процесс уже будет от терминала отсоединен.

Метод exit передает системе Expect сигнал подготовиться к завершению работы и затем закончить ее. Этот метод вызывается неявным образом при достижении конца сценария.

expect [[-opts] pat1 body1] ...
 [-opts] patn [bodyn]
-re

Параметр предваряет регулярное выражение.

-ex

Параметр указывает, что необходимо точное соответствие текстовому шаблону. Подстановочные символы «*», «.», «^», используемые в регулярных выражениях, не интерполируются.

-timeout

Переопределяет значение timeout для данного метода.

default

Определяет окончание периода ожидания (timeout) или достижение конца файла/ввода данных (eof).

null

Определяет нулевой (null) символ.

При совпадении выводимых данных с шаблоном выполняются определенные для него операторы. Метод expect возвращает код завершения выполнения операторов или пустую строку, если совпадений с определенными шаблонами не было.

Если с выводимыми данными совпадает несколько шаблонов, выполняются операторы, определенные только для первого.

Для обработки ситуации, когда совпадений с шаблонами нет, необходимо использовать событие timeout (прекращение обработки выводимых вызванной программой данных по истечении времени, определенного в глобальной или локальной переменной timeout).

При определении текстовых шаблонов необходимо учитывать, что строки, начинающиеся с символа «-», зарезервированы для системных целей.

Пример части сценария, проверяющего результат выполнения подключения к удаленному терминалу:

expect {
busy {puts busy
; user_proc}
failed exit
"invalid password" exit
timeout exit
connected
}

От оператора шаблон отделяется пробелом. Для группировки нескольких операторов в один блок используются скобки {} (первый шаблон). Кавычки « » используются для объединения нескольких слов, разделенных пробелами, в один текстовой шаблон (третий шаблон).

Команда fork создает новый процесс — точную копию текущего.

Метод interact передает контроль над текущим процессом пользователю. Введенные команды и данные направляются на вход (stdin) процесса, выходные данные процесса (stdout, stderr) пересылаются пользователю.

Команда log_file [args] [file]

-noappend

означает «стереть содержимое лог-файла перед началом записи». По умолчанию при вызове метода без этого параметра данные просто добавляются в конец лог-файла.

При вызове метода с указанным именем файла в файл начинают записываться результаты выполнения скрипта. При вызове метода log_file без параметров запись результатов в лог-файл прекращается.

Метод send [-flags] string передает строку вызванной программе или процессу.

send_error [-flags] string
Передать строку на stderr
send_log [-] string
Записать строку в лог-файл.
send_tty [-flags] string
Передать строку устройству /dev/tty.
send_user [-flags] string
Передать строку на stdout.

Метод spawn [args] program [args] создает процесс — псевдотерминал, связанный с программой. Переменной spawn_id присваивается значение дескриптора этого процесса. Процесс, дескриптор которого хранится в переменной spawn_id, считается также текущим. Для контроля результатов нескольких одновременно выполняющихся процессов значение переменной spawn_id можно изменять, присваивая ей значения дескрипторов разных процессов.
Переменные

argc, argv, argv0

Параметры вызова программы хранятся в виде списка в переменной argv. Значение переменной argc устанавливается равным числу переданных параметров. Переменная argv0 определена как имя вызванного сценария или бинарного файла.

send_user "$argv0 [lrange $argv 0 $argc]
"
send_slow {interval delay}

Interval — число передаваемых за один раз байт.

Delay — число секунд, разделяющих передачи данных.

Флаг -s переключает метод send в режим замедленной передачи данных, что позволяет избежать обычной ситуации, когда входной буфер программы или устройства, рассчитанный на прием вводимых человеком данных, переполняется при быстром вводе данных из Expect-сценария.

set send_slow {1 0.5}

timeout — глобальная переменная. Определяет, в течение скольких секунд метод Expect ожидает ввода данных, совпадающих с определенными текстовыми шаблонами. Если за данное время совпадение не было обнаружено, выполняются операции, определенные в методе Expect ключевым словом (событием) timeout. В том случае, когда операции, выполняемые по наступлению события timeout, в методе Expect не были определены, то подразумевается выполнение нулевой операции.

По умолчанию timeout присвоено значение в 10 с. Переустановить timeout можно так:

set timeout 60

Неопределенно большая временная задержка может быть установлена значением -1.
Expect как расширение Tcl

Сценарий Expect является и программой на языке Tcl. Как говорилось ранее, система Expect — это программное расширения языка Tcl, т. е. полностью наследуются логика и синтаксис языка. Вот так будет выглядеть определение и вызов подпрограммы в сценарии Expect:

. . .
# Определение подпрограммы,
осуществляющей смену пароля пользователя
proc update_one_password {user newpassword} {
#вызов команды оболочки passwd
spawn passwd $user
expect "password: "
send $newpasswordк
# подтверждение введенного пароля
expect "password: "
send $newpassword

}
. . .
eval update_one_password $argv
. . .

Следующая часть сценария иллюстрирует применение циклов:

. . .
set default_password new_pass
set list [exec cat list_of_accounts]
foreach account $list {
update_one_password $account
 $default_password
send_user "Пароль для
 пользователя $account изменен."
}
. . .

Следующий пример (e2fsck.exp) является полноценным рабочим сценарием, позволяющим автоматизировать проверку дисков утилитой e2fsck.

#!/usr/bin/expect -f
set timeout -1
spawn /sbin/e2fsck -f $argv
expect {
"Clear? " { send "n" ; exp_continue }
"? "      { send "y" ; exp_continue }
}
Пример использования сценария:
#./e2fsck.exp  /dev/hda3 >log  2>&1

Рассмотрим более интересный сценарий ttrans.exp, осуществляющий передачу файлов любого типа в telnet-сессии. Используются утилиты telnet, uuencode, uudecode, редактор ed.

#!/usr/bin/expect -
if $argc!=1 {
send_user "Usage: ./tr.exp file
"
exit
}
set file [lrange $argv 0 1]
set send_slow {1 0.01}
set timeout 30
set user user_name
set host host_name
set pass user_password
set transf temp_transfer_file
set prompt "(%|#|$)"
catch {set prompt $env(EXPECT_PROMPT)}
spawn telnet $host
expect "ogin"
send "$user
"
expect "password:"
send "$pass
"
expect {
-re $prompt {send_user "
Log in system ok
"}
timeout {send_user "Can't login.
 Exit script.";exit}
}
exec uuencode $file $file > $transf
set out [open $transf r]
send -s "ed -s
"
send -s "a
"
while {-1 != [gets $out Line]} {
send -s $Line
send "
"
send_user "."
}
send ".
"
send "w $transf
"
send "q
"
close $out
send "uudecode $transf
"
expect -re $prompt
send "rm $transf
"
exec rm $transf
expect -re $prompt
#interact
send "exit
"
send_user "
Transfer file complete.
"
exit
# -- end of script --

Запуск сценария осуществляется вызовом:

$./ttrans.exp doc.tgz

Поработав со сценарием, можно убедиться, что такой способ копирования файлов по скорости для ftp-протокола не конкурент. Но интересны сама идея возможности передачи данных таким способом и иллюстрируемые этим примером методы Expect.
Expect и Perl

Методы Expect используются в Perl-программах после установки модуля Expect, а также IO::Tty, IO::Stty c CPAN (Comprehensive Perl Archive Network).

Рекомендую последние версии Perl-модулей. Получают список установленных модулей и их версии следующим способом.

При каждой инсталляции Perl-модуля в файл perllocal.pod, расположенный, например, в /usr/lib/ perl5/5.6.0/i386-linux/perllocal.pod, добавляется описание модуля. Просмотреть список можно так:

$ perldoc perllocal

Установка

Для загрузки и установки нового модуля просто наберите в командной строке:

$ perl -MCPAN -e 'install Expect'
Если хотите более детально
 контролировать ход установки, то:
$ tar xvzf Expect-1.15.tar.gz
$ cd Expect-1.15
$ perl Makefile.PL
$ make
$ make test
$ make install

Краткий обзор работы с модулем

Запуск программы осуществляется вызовом функции spawn модуля Expect. В качестве параметров вызова передаются имя программы и аргументы — одной строкой или списком:

my $progr = Expect-> spawn
($program_to_run,@params)
or "Couldn't spawn program:$!";

Функция spawn возвращает объект, представляющий программу, либо, если вызов не удался, undef.

Для уже созданного дескриптора процесса объект Expect инициализируется так:

my $progr = Expect->exp_init
(*FILEHANDLE);

Приверженцы объектно-ориентированного программирования могут написать в следующем виде:

my $exp = new Expect;
$exp->raw_pty(1);
$exp->spawn($command, @parameters)
 || die "Cannot spawn $command: $!
";

$object->debug(0 | 1 | 2 | 3 | undef) устанавливает уровень вывода отладочных сообщений для объекта. Уровень 1 соответствует выводу общей отладочной информации, уровень 2 предоставляет более подробный отчет, уровень 0 отключает вывод отладочных сообщений. Уровень отладки 3 появился в Expect версии 1.05 — вы получаете всю информацию об изменении буфера обмена Expect-объектом. Если вызвать метод без входных параметров (undef), то он вернет текущий уровень отладки. Для вновь созданных объектов уровень отладки устанавливается значением $Expect::Debug.

$object->raw_pty(1 | 0) устанавливает псевдотерминал в raw-режим перед запуском программы, чем отключается эхо-вывод (echo) на STDOUT и CR->LF-трансляцию, а работа с псевдотерминалом становится похожей на работу с процессом. Эта операция должна быть произведена перед вызовом spawn().

$object->expect($timeout, @match_patterns) или, в стиле Tcl/Expect,

expect($timeout,
'-i', [ $obj1, $obj2, ... ],
[ $re_pattern, sub { ...; exp_continue; },
 @subparms, ],
[ 'eof', sub { ... } ],
[ 'timeout', sub { ... }, $subparm1 ],
'-i', [ $objn, ...],
'-ex', $exact_pattern, sub { ... },
$exact_pattern, sub
{ ...; exp_continue_timeout; },
'-re', $re_pattern, sub { ... },
'-i', @object_list, @pattern_list,
...);

По аналогии с системой Expect для ожидания вывода программой строки используется функция expect. Например, ожидать 50 с до появления приглашения «ftp>»

unless ($progr->expect(50, ?ftp>?))

{ #операция по тайм-ауту}

Ждать неопределенно долго появления «kermit»

unless ($progr->expect
(undef, ?kermit?))

{ #обработка ошибки, произошел сбой в работе программы}

Ждать 50 с до появления приглашения вида «ftp>»или «Ftp>»:

unless ($progr->expect(50,?ftp>?,
 ?Ftp>?)){ # операция по тайм-ауту}

или, используя регулярное выражение с шаблоном поиска /[Ff]tp>]/:

unless ($progr->expect(50,?-re?,?
 [Ff]tp>?)){ # операция по тайм-ауту}

Для использования регулярных выражений при вызове функции expect в качестве первого аргумента указывается время ожидания, в качестве второго — строка «-re», а третий аргумент — строка с шаблоном поиска, затем можно передать другие строки или шаблоны. Возвращаемым скалярным значением Expect является номер элемента, для которого произошло совпадение:

$id = $progr->expect(50, "200",
 "550", "error");
switch ($which)
case 1:	#операция при
 совпадении строки 200
break;
case 2:	#операция при
 совпадении строки 550
break;
case 3:	#операция при
 совпадении строки error
break;

Если ни одна строка не совпала, Expect возвращает false.

Возвращаемым списковым контекстом вызова expect является список из пяти элементов. Первый элемент определяет номер совпавшей строки или шаблона. Второй — строка с описанием причины возврата из expect (при отсутствии ошибок возвращается значение undef, возможные варианты ошибок: «1:TIMEOUT», «2:EOF», «3: spawn id(...) died») и «4:...»(смысл этих сообщений описан в Expect(3)). Третий элемент равен совпавшей строке. Четвертый элемент — текст до совпадения. Пятый — текст после совпадения.

Передать в программу строку «get linux-2.4.17.tgz » можно так:

print $progr ?get linux-2.4.17.tgz
?;

или

$progr->send(?get linux-2.4.17.tgz
?);

Передать управление пользователю:

$progr->interact();

Отключить вывод на STDOUT:

$progr->log_stdout(0);

Если программа завершается сама (например, tail /var/log/messages), то можно использовать:

$progr->soft_close();

Если программа должна быть закрыта извне (например, tail -f /var/log/messages), то принудительное завершение ее:

$progr->hard_close();

Expect::version() — возвращает версию Expect.

$object->log_user(0 | 1 | undef) или
$object->log_stdout(0 | 1 | undef)

разрешает/запрещает отображение переданных объектом данных на STDOUT. Вызов метода без параметров возвращает текущие установки. У созданного объекта данный параметр определяется установленной переменной $Expect:: Log_Stdout variable. Значение по умолчанию 1.

$object->log_file(?filename? | $filehandle | &coderef | undef) — ведение лог-файла. Все символы, переданные или полученные процессом, записываются в файл. Обычно новые данные добавляются в конец уже имеющихся в указанном файле, но, установив режим записи «w», можно в начале сессии очистить содержимое файла:

$object->log_file(?filename?, ?w?);

Вызов метода со значением undef останавливает запись и закрывает лог-файл:

$object->log_file(undef);

При вызове без параметров возвращает имя лог-файла:

$fh = $object->log_file();

Можно указать ссылку на пользовательскую функцию, которая будет вызываться вместо записи в файл:

$object->log_file(&myloggerfunc);
$object->print_log_file(@strings)

— записывает массив @strins в лог-файл или передает для обработки функции, определенной вызовом log_file. Запись текста можно сделать вызовом $object->log_file->print(), но это работает только для лог-файлов, а не для функций обработчиков.

$object->send_slow($delay, @strings);

Метод печатает каждый символ для каждой строки из массива @strings с заданной паузой в $delay секунд. Это удобно для работы с устройствами типа модемов, сбой в функционировании может возникнуть, если передавать данные недостаточно медленно.
Примеры работы с модулем Expect.pm
Использование средств отладки

use Expect;
$Expect::Log_Stdout = 1;
$Expect::Debug = 3;
$Expect::Exp_Internal = 1;
$timeout = 60;
$lpc = Expect->spawn("lpc")
||die "Can't spawn lpc:$!
";
$lpc->Expect($timeout,"lpc>")
 && print $lpc "stat
";
$lpc->hard_close();

Автоматизация подключения к удаленному серверу по ssh

#!/usr/bin/perl
use Expect;
$SSH="/usr/bin/ssh";
if ($#ARGV!=2){
print "usage: ./login-ssh.pl
 host login password
";
exit -1;
}
$timeout=50;
my ($host,$login,$pass)=@ARGV;
my $ssh=new Expect;
$ssh->raw_pty(1);
$ssh->spawn($SSH,"-l", $login,$host)
||die "can't spawn ssh: $!
";
my $spawn_ok;
$ssh->expect($timeout,
[
'assword: $',
sub {
my $fn = shift;
print $fn "$pass
";
exp_continue;
}
],
[
eof =>sub {
if ($spawn_ok){
die "Ошибка: преждевременный выход.
";
} else {
die "Ошибка: некорректная работа с ssh.
";
}
}
],
[
timeout => sub {
die "No login.
"
}
],
"-re","[$#>:]", sub {
my $fn = shift;
$fn->interact();
}
);

Поддержка

Узнать последние новости по разработке и обновлению Perl-модуля Expect, получить ответ на интересующий вас вопрос можно в дискуссионных группах:

http://lists.sourceforge.net/lists/listinfo/expectperl-announce

http://lists.sourceforge.net/lists/listinfo/expectperl-discuss

Ответы на общие вопросы, связанные с Рerl или CPAN, можно найти так:

$ perldoc perlfunc.

Или в Интернете по адресу http://www.perl.com/CPAN-local//.
Expect и C (libexpect)

Пользоваться методами системы Expect в программах на языках Cи и Cи++ поможет библиотека libexpect. В заголовок файла с исходным кодом программы надо включить следующие строки:

#include expect_tcl.h
Expect_Init(interp);

Компиляция такой программы будет выглядеть следующим образом:

$cc myproc.c -o myproc
 -lexpect5.31 -ltcl7.5

Более подробную информацию на эту тему содержит документация, поставляемая с системой.
* * *

Expect предоставляет уникальные возможности для решения системных задач. Являясь общецелевой программной системой, Expect поддерживает работу с сетевыми сервисами и графическим пользовательским интерфейсом. Если для повседневной работы вам нужен только один язык программирования, Expect будет оптимален.
Литература:

    Don Libes Exploring Expect. O'Reilly, 1994. 599 с.
    Кеннет Розен. UNIX System V Release 4. Лори, 1999. 762 с.
    Петерсен Р. LINUX: Полное руководство. 3-е изд. BHV Киев, 2000. 800 c.
    Болл Б. Red Hat Linux 7: Энциклопедия пользователя. DiaSoft, 2001. 592 с.


    
